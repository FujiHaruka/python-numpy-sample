import unittest
import numpy as np
from キャリブレーションv3 import (
    対角小行列の成分かどうかを調べる行列,
    対角小行列を除外する,
    移出ベクトルとの差を行方向に分配する,
    移出ベクトルとの差が正になる行を抜き出す,
    移出ベクトルとの差が負になる行を抜き出す,
    行和に対する比率行列を求める,
    列和に対する比率行列を求める,
    列方向の補正行列を調整する,
)


class TestStringMethods(unittest.TestCase):

    def test_対角小行列の成分かどうかを調べる行列(self):
        np.testing.assert_equal(
            対角小行列の成分かどうかを調べる行列(元行列サイズ=6, 小行列サイズ=2),
            np.array([
                [True, True, False, False, False, False],
                [True, True, False, False, False, False],
                [False, False, True, True, False, False],
                [False, False, True, True, False, False],
                [False, False, False, False, True, True],
                [False, False, False, False, True, True],
            ])
        )

    def test_対角小行列を除外する(self):
        元行列 = np.array([
            [1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1],
        ], dtype=float)
        np.testing.assert_equal(
            対角小行列を除外する(元行列, 小行列サイズ=2),
            np.array([
                [0, 0, 1, 1, 1, 1],
                [0, 0, 1, 1, 1, 1],
                [1, 1, 0, 0, 1, 1],
                [1, 1, 0, 0, 1, 1],
                [1, 1, 1, 1, 0, 0],
                [1, 1, 1, 1, 0, 0],
            ], dtype=float)
        )

    def test_移出ベクトルとの差を行方向に分配する(self):
        元行列 = np.array([
            [0, 0, 1, 2, 1, 2],
            [0, 0, 3, 4, 3, 1],
            [1, 2, 0, 0, 1, 1],
            [4, 4, 0, 0, 3, 4],
            [1, 2, 5, 2, 0, 0],
            [3, 4, 2, 4, 0, 0],
        ], dtype=float)
        移出ベクトル = np.array([10, 10, 10, 10, 10, 10], dtype=float)
        行の和ベクトル = np.array([6, 11, 5, 15, 10, 13], dtype=float)
        移出ベクトルとの差 = 移出ベクトル - 行の和ベクトル
        行方向の補正量分配行列 = 移出ベクトルとの差を行方向に分配する(元行列, 移出ベクトルとの差, 小行列サイズ=2)
        np.testing.assert_almost_equal(
            行方向の補正量分配行列,
            np.array([
                [0, 0, 0.66666667, 1.33333333, 0.66666667, 1.33333333],
                [0, 0, 0, 0, 0, 0],
                [1, 2, 0, 0, 1, 1],
                [0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0]
            ])
        )

    def test_移出ベクトルとの差が正になる行を抜き出す(self):
        元行列 = np.array([
            [0, 0, 1, 2, 1, 2],
            [0, 0, 3, 4, 3, 1],
            [1, 2, 0, 0, 1, 1],
            [4, 4, 0, 0, 3, 4],
            [1, 2, 5, 2, 0, 0],
            [3, 4, 2, 4, 0, 0],
        ])
        移出ベクトルとの差 = np.array([1, -1, 1, -1, -1, 1])
        np.testing.assert_equal(
            移出ベクトルとの差が正になる行を抜き出す(元行列, 移出ベクトルとの差),
            np.array([
                [0, 0, 1, 2, 1, 2],
                [0, 0, 0, 0, 0, 0],
                [1, 2, 0, 0, 1, 1],
                [0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0],
                [3, 4, 2, 4, 0, 0],
            ])
        )

    def test_行和に対する比率行列を求める(self):
        np.testing.assert_almost_equal(
            行和に対する比率行列を求める(np.array([
                [1, 4, 0],
                [12, 13, 0],
                [0, 0, 0]
            ])),
            np.array([
                [0.2, 0.8, 0],
                [0.48, 0.52, 0],
                [0, 0, 0],
            ])
        )

    def test_列和に対する比率行列を求める(self):
        np.testing.assert_almost_equal(
            列和に対する比率行列を求める(np.array([
                [1, 12, 0],
                [4, 13, 0],
                [0, 0, 0],
            ])),
            np.array([
                [0.2, 0.48, 0],
                [0.8, 0.52, 0],
                [0, 0, 0],
            ])
        )

    def test_列方向の補正行列を調整する(self):
        # 移出ベクトルとの差が負になる行だけを抜き出してある
        補正前行列 = np.array([
            [0, 0, 0, 0, 0, 0],
            [0, 0, 3, 4, 3, 1],
            [0, 0, 0, 0, 0, 0],
            [4, 4, 0, 0, 3, 4],
            [0, 0, 0, 0, 0, 0],
            [3, 4, 2, 4, 0, 0],
        ])
        移出ベクトルとの差 = np.array([0, -1, 0, -5, 0, -3])
        列方向の補正量総和ベクトル = -1 * np.array([1, 2, 0.667, 1.33, 1.67, 2.33])

        調整1回目 = 列方向の補正行列を調整する(補正前行列, 移出ベクトルとの差, 列方向の補正量総和ベクトル)
        # excel の計算結果と一致することを確認する
        np.testing.assert_almost_equal(
            調整1回目,
            [
                [0., 0., 0., 0., 0., 0.],
                [0., 0., -0.24774286, -0.37586957, -0.35785714, -0.1487234],
                [0., 0., 0., 0., 0., 0.],
                [-0.65822785, -1.18181818, 0., 0., -1.31214286, -2.1812766],
                [0., 0., 0., 0., 0., 0.],
                [-0.34177215, -0.81818182, -0.41925714, -0.95413043, 0., 0.]
            ]
        )
        # 各列の和が列方向の補正量総和ベクトルと一致することを確認
        np.testing.assert_almost_equal(
            調整1回目.sum(axis=0),
            列方向の補正量総和ベクトル
        )

        調整2回目 = 列方向の補正行列を調整する(調整1回目, 移出ベクトルとの差, 列方向の補正量総和ベクトル)
        # excel の計算結果と一致することを確認する
        np.testing.assert_almost_equal(
            調整2回目,
            [
                [0., 0., 0., 0., 0., 0.],
                [0., 0., -0.20429076, -0.30244929, -0.3418669, -0.14087259],
                [0., 0., 0., 0., 0., 0.],
                [-0.60390683, -1.06694392, 0., 0., -1.3281331, -2.18912741],
                [0., 0., 0., 0., 0., 0.],
                [-0.39609317, -0.93305608, -0.46270924, -1.02755071, 0., 0.]
            ]
        )
        # 各列の和が列方向の補正量総和ベクトルと一致することを確認
        np.testing.assert_almost_equal(
            調整2回目.sum(axis=0),
            列方向の補正量総和ベクトル
        )

        調整3回目 = 列方向の補正行列を調整する(調整2回目, 移出ベクトルとの差, 列方向の補正量総和ベクトル)
        # 各列の和が列方向の補正量総和ベクトルと一致することを確認
        np.testing.assert_almost_equal(
            調整3回目.sum(axis=0),
            列方向の補正量総和ベクトル
        )

        # だんだん誤差が小さくなることを確認する
        調整1回目の誤差 = np.linalg.norm(調整1回目.sum(axis=1) - 移出ベクトルとの差)
        調整2回目の誤差 = np.linalg.norm(調整2回目.sum(axis=1) - 移出ベクトルとの差)
        調整3回目の誤差 = np.linalg.norm(調整3回目.sum(axis=1) - 移出ベクトルとの差)
        self.assertTrue(調整1回目の誤差 > 調整2回目の誤差)
        self.assertTrue(調整2回目の誤差 > 調整3回目の誤差)


if __name__ == '__main__':
    unittest.main()
