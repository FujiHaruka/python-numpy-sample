from numpy import ndarray

import numpy as np


def キャリブレートv2(元行列: ndarray, 移出ベクトル: ndarray, 小行列サイズ: int):
    # 引数のサイズ検証
    元行列の行数, 元行列の列数 = 元行列.shape
    移出ベクトルの行数, = 移出ベクトル.shape
    if 元行列の行数 != 移出ベクトルの行数:
        raise Exception("元行列の行数と移出ベクトルの行数が一致しません")
    if 元行列の行数 % 小行列サイズ != 0:
        raise Exception("元行列の行数が小行列サイズで割り切れません")

    # ステップ1
    行の和ベクトル = 元行列.sum(axis=1, dtype=float)
    対角小行列の和ベクトル = np.zeros(元行列の行数, dtype=float)
    for 行 in range(元行列の行数):
        対角小行列の和ベクトル[行] = 行の対角小行列成分の和(元行列, 小行列サイズ, 行)
    Bベクトル = 行の和ベクトル - 対角小行列の和ベクトル
    # print(f"Bベクトル {Bベクトル}")

    # ステップ2
    移出ベクトルとの差 = 移出ベクトル - Bベクトル

    # ステップ3
    for 行 in range(元行列の行数):
        # 移出ベクトルとの差が負の行は「過多」、正の行は「過少」
        # 過多な行だけキャリブレーションの対象になるので過少な行は無視
        if 移出ベクトルとの差[行] >= 0:
            continue

        for 列 in range(元行列の列数):
            if 対角小行列の成分である(小行列サイズ, 行, 列):
                continue

            # 補正量 は (d - b) * a / b
            補正量 = 移出ベクトルとの差[行] * 元行列[行, 列] / Bベクトル[行]
            # 補正量は負の値だからここでは加算でいい
            # print(f"({行}, {列}) を補正量 {補正量} で補正する")
            元行列[行, 列] += 補正量

            # 下の列に対する調整
            # まずは下の列の和を計算する
            下の列の和 = 0
            for 下の行 in range(行 + 1, 元行列の行数):
                # 過少な行だけが対象になるので過多な行は無視
                if 移出ベクトルとの差[下の行] <= 0:
                    continue
                if 対角小行列の成分である(小行列サイズ, 下の行, 列):
                    continue
                下の列の和 += 元行列[下の行, 列]

            if 下の列の和 == 0:
                continue

            # 次に列方向の補正を行う
            for 下の行 in range(行 + 1, 元行列の行数):
                if 移出ベクトルとの差[下の行] <= 0:
                    continue
                if 対角小行列の成分である(小行列サイズ, 下の行, 列):
                    continue
                下の行の補正量 = 補正量 * 元行列[下の行, 列] / 下の列の和
                # print(f"下の行 ({下の行}, {列}) を補正量 {下の行の補正量} で補正する")
                元行列[下の行, 列] -= 下の行の補正量

    return 元行列


def 対角小行列の成分である(小行列サイズ, 行, 列):
    # k = h のこと
    return 行 // 小行列サイズ == 列 // 小行列サイズ


def 行の対角小行列成分の和(元行列, 小行列サイズ, 行):
    return 元行列[行, 小行列サイズ * (行 // 小行列サイズ):小行列サイズ * (行 // 小行列サイズ + 1)].sum()
