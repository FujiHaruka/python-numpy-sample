from numpy import ndarray, where

import numpy as np

# ゼロ除算したときの警告を非表示にする設定。警告がよく出るので非表示にした
np.seterr(divide='ignore', invalid='ignore')


def キャリブレートv2(元行列: ndarray, 移出ベクトル: ndarray, 小行列サイズ: int):
    # 引数のサイズ検証
    元行列の行数, 元行列の列数 = 元行列.shape
    移出ベクトルの行数, = 移出ベクトル.shape
    if 元行列の行数 != 移出ベクトルの行数:
        raise Exception("元行列の行数と移出ベクトルの行数が一致しません")
    if 元行列の行数 % 小行列サイズ != 0:
        raise Exception("元行列の行数が小行列サイズで割り切れません")

    # 対角小行列を除外した行の和を求め、移出ベクトルとの差をとる
    対角小行列を除外した元行列 = 対角小行列を除外する(元行列, 小行列サイズ)
    行の和ベクトル = 対角小行列を除外した元行列.sum(axis=1, dtype=float)
    移出ベクトルとの差 = 移出ベクトル - 行の和ベクトル

    行方向の補正量分配行列 = 移出ベクトルとの差を行方向に分配する(
        対角小行列を除外した元行列, 移出ベクトルとの差, 行の和ベクトル, 小行列サイズ)

    列方向の調整量ベクトル = 行方向の補正量分配行列.sum(axis=0, dtype=float)

    移出ベクトルとの差が負になる行の元行列 = 移出ベクトルとの差が負になる行を抜き出す(対角小行列を除外した元行列, 移出ベクトルとの差)
    列方向の比率行列 = 移出ベクトルとの差を分配する(移出ベクトルとの差が負になる行の元行列, 移出ベクトルとの差)


def 対角小行列の成分かどうかを調べる行列(元行列サイズ: int, 小行列サイズ: int) -> ndarray:
    # 元行列と小行列が両方とも正方行列であると仮定している
    # こういうコードを書き始めるとすごく numpy っぽい
    列番号の行列 = np.tile(np.arange(元行列サイズ), 元行列サイズ).reshape((元行列サイズ, 元行列サイズ))
    行番号の行列 = 列番号の行列.T
    対角小行列の成分か = 行番号の行列 // 小行列サイズ == 列番号の行列 // 小行列サイズ
    return 対角小行列の成分か


def 対角小行列を除外する(元行列: ndarray, 小行列サイズ: int) -> ndarray:
    対角小行列の成分か = 対角小行列の成分かどうかを調べる行列(元行列.shape[0], 小行列サイズ)
    元行列から対角小行列を除外したもの = np.where(
        対角小行列の成分か,
        np.zeros(元行列.shape),
        元行列,
    )
    return 元行列から対角小行列を除外したもの


def 移出ベクトルとの差を行方向に分配する(元行列: ndarray, 移出ベクトルとの差: ndarray, 行の和ベクトル: ndarray, 小行列サイズ: int) -> ndarray:
    移出ベクトルとの差_縦 = 移出ベクトルとの差.reshape((移出ベクトルとの差.size, 1))
    行の和ベクトル_縦 = 行の和ベクトル.reshape((行の和ベクトル.size, 1))
    対角小行列の成分か = 対角小行列の成分かどうかを調べる行列(元行列.shape[0], 小行列サイズ)
    行方向の補正量分配行列 = np.where(
        # 対角小行列の成分であるか、または移出ベクトルとの差が0以下だったら0にする
        np.logical_or(
            対角小行列の成分か,
            移出ベクトルとの差_縦 <= 0,
        ),
        0,
        # 実は行列とベクトルとの四則演算が可能
        移出ベクトルとの差_縦 * 元行列 / 行の和ベクトル_縦
    )
    return 行方向の補正量分配行列


def 移出ベクトルとの差が正になる行を抜き出す(元行列: ndarray, 移出ベクトルとの差: ndarray) -> ndarray:
    移出ベクトルとの差_縦 = 移出ベクトルとの差.reshape((移出ベクトルとの差.size, 1))
    return np.where(
        移出ベクトルとの差_縦 > 0,
        元行列,
        0
    )


def 移出ベクトルとの差が負になる行を抜き出す(元行列: ndarray, 移出ベクトルとの差: ndarray) -> ndarray:
    移出ベクトルとの差_縦 = 移出ベクトルとの差.reshape((移出ベクトルとの差.size, 1))
    return np.where(
        移出ベクトルとの差_縦 < 0,
        元行列,
        0
    )


def 移出ベクトルとの差を分配する(移出ベクトルとの差が負になる行の元行列: ndarray, 移出ベクトルとの差: ndarray) -> ndarray:
    移出ベクトルとの差_縦 = 移出ベクトルとの差.reshape((移出ベクトルとの差.size, 1))
    行の和ベクトル = 移出ベクトルとの差が負になる行の元行列.sum(axis=1, dtype=float)
    行の和ベクトル_縦 = 行の和ベクトル.reshape((行の和ベクトル.size, 1))
    列方向の比率行列 = np.where(
        移出ベクトルとの差_縦 < 0,
        移出ベクトルとの差が負になる行の元行列 * 移出ベクトルとの差_縦 / 行の和ベクトル_縦,
        0,
    )
    return 列方向の比率行列


def 行方向の和に対する比率行列を求める(行列: ndarray) -> ndarray:
    """
    行列の成分 a_ij 、行列の各行の和 S_i としたとき、 a_ij / S_i を成分とする同じサイズの行列を作る
    ただし S_i = 0 となる行は無視する
    """
    行の和ベクトル = 行列.sum(axis=1, dtype=float)
    行の和ベクトル_縦 = 行の和ベクトル.reshape((行の和ベクトル.size, 1))
    return np.where(
        行の和ベクトル_縦 != 0,
        行列 / 行の和ベクトル_縦,
        行列,
    )


def 列方向の和に対する比率行列を求める(行列: ndarray) -> ndarray:
    """
    行列の成分 a_ij 、行列の各列の和 S_j としたとき、 a_ij / S_j を成分とする同じサイズの行列を作る
    ただし S_j = 0 となる行は無視する
    """
    列の和ベクトル = 行列.sum(axis=0, dtype=float)
    return np.where(
        列の和ベクトル != 0,
        行列 / 列の和ベクトル,
        行列,
    )
